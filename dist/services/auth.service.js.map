{"version":3,"sources":["../../src/services/auth.service.ts"],"sourcesContent":["import { hash, compare } from 'bcrypt';\nimport { sign, verify } from 'jsonwebtoken';\nimport { SECRET_KEY } from '@config';\nimport { HttpException } from '@exceptions/HttpException';\nimport { User } from '@interfaces/users.interface';\nimport userModel from '@models/users.model';\nimport { isEmpty } from '@utils/util';\nimport { initializeDbConnection, stripe } from '@/app';\nimport { RolesEnum } from '../enums/RolesEnums';\nimport uid from 'uid';\nimport moment from 'moment';\nimport { transporter } from '@/app';\n\nclass AuthService {\n  public users = userModel;\n\n  public async signup(userData) {\n    if (!userData) throw new HttpException(400, 'userData is empty');\n    \n    const signupSession = initializeDbConnection().session({ database: 'neo4j' });\n    const createWalletSession = initializeDbConnection().session({ database: 'neo4j' });\n\n    const email = userData.email;\n    try {\n      const findUser = await signupSession.executeRead(tx => tx.run('match (u:user {email: $email}) return u', { email: email }));\n      if (findUser.records.length > 0) return { message: `This email ${userData.email} already exists` };\n      const hashedPassword = await hash(userData.password, 10);\n      if ( !userData.firstName || !userData.lastName || !userData.email || !userData.phoneNumber) return { message: 'mlissing data' };\n          const createdUserBuyer = await \n          \n          signupSession.executeWrite(tx =>\n            tx.run(\n              'create (u:user {id: $userId, name: $name, email: $email, phone: $phoneNumber, createdAt: $createdAt}) return u',\n              {\n                userId: uid.uid(40),\n                createdAt: moment().format('MMMM DD, YYYY'),\n                email: email,\n                phoneNumber: userData.phoneNumber,\n                name: `${userData.firstName} ${userData.lastName}`,\n              },\n            ),\n          );\n\n          const buyerToken = this.createToken(process.env.EMAIL_SECRET, createdUserBuyer.records.map(record => record.get('u').properties.id)[0]);\n          this.sendSignUpEmail(email);\n\n          return { tokenData: buyerToken, data: createdUserBuyer.records.map(record => record.get('u').properties)[0] };\n         \n    } catch (error) {\n      console.log(error);\n    } finally {\n      await signupSession.close();\n      await createWalletSession.close();\n    }\n  }\n\n  public async sendSignUpEmail(email: string) {\n    try {\n      const mailOptions = {\n        template: 'verifying_email',\n        from: process.env.USER_EMAIL,\n        to: process.env.USER_EMAIL,\n        subject: 'Signup alert',\n        context: {\n          email: email,\n        },\n      };\n\n      transporter.sendMail(mailOptions, (error: any, data: any) => {\n        if (error) console.log(error);\n        if (!error) console.log('sent');\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public async resendVerificationEmail(email: string) {\n    const getUserByEmailSession = initializeDbConnection().session();\n\n    try {\n      const user = await getUserByEmailSession.executeRead(tx => tx.run(\"match (u:user {email: $email})-[:IS_A]->(b:buyer) return u, b\", {\n        email: email\n      }));\n  \n      const tokenData = this.createToken(process.env.EMAIL_SECRET, user.records.map(record => record.get('u').properties.id)[0])\n  \n\n      const mailOptions = {\n        template: 'verifying_email',\n        from: process.env.USER,\n        to: email,\n        subject: 'Verifying Email',\n        context: {\n          userName: user.records.map(record => record.get('u').properties.userName)[0],\n          token: tokenData.token,\n          domain: process.env.DOMAIN,\n          role: user.records.map(record => record.get('b').properties).length == 0 ? \"Seller\" : \"Buyer\",\n        },\n      };\n\n      transporter.sendMail(mailOptions, (error: any, data: any) => {\n        if (error) console.log(error);\n        if (!error) console.log('sent');\n      });\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public async changePassword(email: String, userData: any) {\n    const checkUserSession = initializeDbConnection().session();\n    const changePasswordSession = initializeDbConnection().session();\n    try {\n\n      const findUser = await checkUserSession.executeRead(tx => tx.run('match (u:user {email: $email}) return u', { email: email }));\n      if (findUser.records.length == 0) return { message: `old password is incorrect` };\n\n      const password = findUser.records.map(record => record.get('u').properties.password)[0];\n      const isPasswordMatching = await compare(userData.data.oldPassword, password);\n      if (!isPasswordMatching) return { message: 'old password is incorrect' };\n      const hashedPassword = await hash(userData.data.newPassword, 10);\n      const changedPassword = await changePasswordSession.executeWrite(tx =>\n        tx.run('match (u {email: $email}) set u.password = $newPassword return u', {\n          email: email,\n          newPassword: hashedPassword,\n        }),\n      );\n\n      return changedPassword.records.map(record => record.get('u').properties)[0];\n    } catch (error) {\n      console.log(error);\n    } finally {\n      changePasswordSession.close();\n    }\n  }\n\n  public async login(userData) {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n    const loginSession = initializeDbConnection().session({ database: 'neo4j' });\n\n    try {\n      const email = userData.data.email;\n\n      const findUser = await loginSession.executeRead(tx => tx.run('match (u:user {email: $email}) return u', { email: email }));\n      if (findUser.records.length == 0) return { message: `password or email is incorrect` };\n\n      const password = findUser.records.map(record => record.get('u').properties.password)[0];\n      const isPasswordMatching = await compare(userData.data.password, password);\n      const userId = findUser.records.map(record => record.get('u').properties.id)[0];\n\n      if (!isPasswordMatching) return { message: 'password or email is incorrect' };\n\n      const tokenData = this.createToken(\n        process.env.SECRET_KEY,\n        userId,\n      );\n\n      return { tokenData, data: findUser.records.map(record => record.get('u').properties)[0]};\n    } catch (error) {\n      console.log(error);\n    } finally {\n      loginSession.close();\n    }\n  }  \n  \n\n  public async refreshToken(id: string) {\n\n    if (!id) return { message: 'missing token' };\n    const refreshSession = initializeDbConnection().session({ database: 'neo4j' });\n    try {\n      const tokenData = this.createRefreshToken(id);\n\n      return { tokenData };\n    } catch (error) {\n      console.log(error);\n    } finally {\n      refreshSession.close();\n    }\n  }\n\n  public async logout(userData: User): Promise<User> {\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\n\n    const findUser: User = this.users.find(user => user.email === userData.email && user.password === userData.password);\n    if (!findUser) throw new HttpException(409, \"User doesn't exist\");\n\n    return findUser;\n  }\n\n  public createToken(secret: string, data: any) {\n    try {\n      const dataStoredInToken = { id: data };\n      const secretKey: string = secret;\n      const expiresAt: string = '280s';\n      const expiresIn: Date = new Date();\n      console.log(expiresIn);\n      expiresIn.setTime(expiresIn.getTime() + 60000);\n\n      console.log(expiresIn);\n\n\n      return { token: sign(dataStoredInToken, secretKey, { expiresIn: expiresAt }), expiresIn: moment(expiresIn).format(\"YYYY-MM-DD HH:mm:ss.ms\") };\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public createRefreshToken(data) {\n    try {\n      const dataStoredInToken = { id: data, refresh: true };\n\n      const secretKey: string = SECRET_KEY;\n      const expiresAt: string = '280s';\n      const expiresIn: Date = new Date();\n      expiresIn.setTime(expiresIn.getTime() + 60);\n\n      return { token: sign(dataStoredInToken, secretKey, { expiresIn: expiresAt }), expiresIn: moment(expiresIn).format(\"YYYY-MM-DD hh:mm:ss.ms\") };\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  public createCookie(tokenData): string {\n    return `Authorization=${tokenData.token}; HttpOnly; Max-Age=${tokenData.expiresIn};`;\n  }\n}\n\nexport default AuthService;\n"],"names":["AuthService","signup","userData","HttpException","signupSession","initializeDbConnection","session","database","createWalletSession","email","findUser","executeRead","tx","run","records","length","message","hashedPassword","hash","password","firstName","lastName","phoneNumber","createdUserBuyer","executeWrite","userId","uid","createdAt","moment","format","name","buyerToken","createToken","process","env","EMAIL_SECRET","map","record","get","properties","id","sendSignUpEmail","tokenData","data","error","console","log","close","mailOptions","template","from","USER_EMAIL","to","subject","context","transporter","sendMail","resendVerificationEmail","getUserByEmailSession","user","USER","userName","token","domain","DOMAIN","role","changePassword","checkUserSession","changePasswordSession","isPasswordMatching","compare","oldPassword","newPassword","changedPassword","login","isEmpty","loginSession","SECRET_KEY","refreshToken","refreshSession","createRefreshToken","logout","users","find","secret","dataStoredInToken","secretKey","expiresAt","expiresIn","Date","setTime","getTime","sign","refresh","createCookie","userModel"],"mappings":"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"}
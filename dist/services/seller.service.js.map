{"version":3,"sources":["../../src/services/seller.service.ts"],"sourcesContent":["import { initializeDbConnection } from '@/app';\r\nimport Stripe from 'stripe';\r\nimport { Buffer } from 'node:buffer';\r\nimport { writeFile } from 'node:fs';\r\nimport path from 'node:path';\r\nimport moment from 'moment';\r\n\r\nclass sellerService {\r\n  private stripe = new Stripe(process.env.STRIPE_TEST_KEY, { apiVersion: '2022-11-15' });\r\n  public prices = [];\r\n\r\n  public async createSubscribePlans(userId: string, subscriptionPlansData: any[]) {\r\n    try {\r\n      const createdSubscriptionPlans = subscriptionPlansData.data.subscriptionPlans.map(subscriptionPlan => {\r\n        return this.createSubscribePlan(subscriptionPlan.subscriptionPlanPrice, subscriptionPlan.subscriptionPlanTitle, userId);\r\n      });\r\n\r\n      const subscriptionPlans = await Promise.all(createdSubscriptionPlans);\r\n\r\n      return subscriptionPlans;\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  }\r\n\r\n  public async getSubscriptiionPlans(userId: string) {\r\n    try {\r\n      const getSubscriptionPlansSession = initializeDbConnection().session();\r\n\r\n      const subscriptionPlans = await getSubscriptionPlansSession.executeWrite(tx =>\r\n        tx.run('match (user {id: $userId})-[:IS_A]->(s:seller)-[:HAS_A]->(subscriptionPlan:subscriptionPlan) return subscriptionPlan', {\r\n          userId: userId,\r\n        }),\r\n      );\r\n\r\n      return subscriptionPlans.records.map(record => record.get('subscriptionPlan').properties);\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  }\r\n\r\n  public createSubscribePlan = async (subscriptionPlanPrice: number, subscriptionPlanTitle: string, userId: string) => {\r\n    const createSubscribePlansSession = initializeDbConnection().session();\r\n    try {\r\n      const product = await this.stripe.products.create({\r\n        name: subscriptionPlanTitle,\r\n      });\r\n\r\n      const price = await this.stripe.prices.create({\r\n        unit_amount: subscriptionPlanPrice * 100,\r\n        currency: 'eur',\r\n        recurring: { interval: 'month' },\r\n        metadata: {\r\n          sellerId: userId,\r\n        },\r\n        product: product.id,\r\n      });\r\n\r\n      const createdPlans = await createSubscribePlansSession.executeWrite(tx =>\r\n        tx.run(\r\n          'match (user {id: $userId})-[:IS_A]->(s:seller) create (s)-[:HAS_A]->(subscriptionPlan:subscriptionPlan {id: $subscriptionPlanId, price: $subscriptionPlanPrice, title: $subscriptionPlanTitle}) return subscriptionPlan',\r\n          {\r\n            subscriptionPlanPrice: subscriptionPlanPrice,\r\n            subscriptionPlanTitle: subscriptionPlanTitle,\r\n            userId: userId,\r\n            subscriptionPlanId: price.id,\r\n          },\r\n        ),\r\n      );\r\n\r\n      return createdPlans.records.map(record => record.get('subscriptionPlan').properties);\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      createSubscribePlansSession.close();\r\n    }\r\n  };\r\n\r\n  public getFollowersCount = async (sellerId: string) => {\r\n    const getFlowwersSession = initializeDbConnection().session();\r\n    try {\r\n      const followersCount = await getFlowwersSession.executeWrite(tx =>\r\n        tx.run('match (u:user)-[s:SUBSCRIBED_TO]->(seller {id: $sellerId}) return count(s) as followersCount', {\r\n          sellerId: sellerId,\r\n        }),\r\n      );\r\n      \r\n      return followersCount.records.map(record => record.get(\"followersCount\"))[0].low;\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      getFlowwersSession.close();\r\n    }\r\n  };\r\n\r\n  public uploadIdentityCard = async (identityCardData: any, userId: string) => {\r\n    try {\r\n      for (let key in identityCardData) {\r\n        console.log(identityCardData[key][0]);\r\n        \r\n        const filecontent = Buffer.from(identityCardData[key][0].buffer, 'binary');\r\n\r\n        writeFile(path.join(__dirname, \"../../public/files/identity_cards\", `${moment().format(\"ssMMyyyy\")}${userId}${identityCardData[key][0].originalname.replace(\".\", \"\")}`), filecontent, (err) => {\r\n          if (err) return console.log(err);\r\n          this.uploadIdentityCardToDb(`/public/files/identity_cards/${moment().format(\"ssMMyyyy\")}${userId}${identityCardData[key][0].originalname.replace(\".\", \"\")}`, userId, identityCardData[key].fieldname);\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  };\r\n\r\n  public uploadIdentityCardToDb = async (location: string, userId: string, side: string) => {\r\n    const uploadIdentityCardSession = initializeDbConnection().session();\r\n    try {\r\n      switch (side) {\r\n        case 'frontSide':\r\n          await uploadIdentityCardSession.executeWrite(tx =>\r\n            tx.run('match (user {id: $userId})-[:IS_A]->(s:seller) set s.frontIdentityCard = $frontIdentityCard', {\r\n              userId: userId,\r\n              frontIdentityCard: location,\r\n            }),\r\n          );\r\n          break;\r\n        case 'backSide':\r\n          await uploadIdentityCardSession.executeWrite(tx =>\r\n            tx.run('match (user {id: $userId})-[:IS_A]->(s:seller) set s.backtIdentityCard = $backIdentityCard', {\r\n              userId: userId,\r\n              backIdentityCard: location,\r\n            }),\r\n          );\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      uploadIdentityCardSession.close();\r\n    }\r\n  };\r\n\r\n  \r\n}\r\n\r\nexport default sellerService;\r\n"],"names":["sellerService","createSubscribePlans","userId","subscriptionPlansData","createdSubscriptionPlans","data","subscriptionPlans","map","subscriptionPlan","createSubscribePlan","subscriptionPlanPrice","subscriptionPlanTitle","Promise","all","error","console","log","getSubscriptiionPlans","getSubscriptionPlansSession","initializeDbConnection","session","executeWrite","tx","run","records","record","get","properties","stripe","Stripe","process","env","STRIPE_TEST_KEY","apiVersion","prices","createSubscribePlansSession","product","products","create","name","price","unit_amount","currency","recurring","interval","metadata","sellerId","id","createdPlans","subscriptionPlanId","close","getFollowersCount","getFlowwersSession","followersCount","low","uploadIdentityCard","identityCardData","key","filecontent","Buffer","from","buffer","writeFile","path","join","__dirname","moment","format","originalname","replace","err","uploadIdentityCardToDb","fieldname","location","side","uploadIdentityCardSession","frontIdentityCard","backIdentityCard"],"mappings":"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"}
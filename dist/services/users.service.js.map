{"version":3,"sources":["../../src/services/users.service.ts"],"sourcesContent":["import { hash } from 'bcrypt';\r\nimport { HttpException } from '@exceptions/HttpException';\r\nimport { User } from '@interfaces/users.interface';\r\nimport { writeFile } from 'node:fs';\r\nimport { Buffer } from 'node:buffer';\r\nimport { isEmpty } from '@utils/util';\r\nimport { initializeDbConnection, stripe } from '@/app';\r\nimport { verify } from 'jsonwebtoken';\r\nimport path from 'node:path';\r\nimport OpenAi from 'openai';\r\n\r\nclass UserService {\r\n  public prices = [];\r\n\r\n  public async findUserById(userId) {\r\n    const getUserSession = initializeDbConnection().session();\r\n    try {\r\n      const result = await getUserSession.executeRead(tx =>\r\n        tx.run('match (u:user {id: $userId}) return u', {\r\n          userId: userId,\r\n        }),\r\n      );\r\n\r\n      if (result.records.length == 0) throw new HttpException(409, \"User doesn't exist\");\r\n\r\n      return result.records.map(record => record.get('u').properties)[0];\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      getUserSession.close();\r\n    }\r\n  }\r\n\r\n  public async generateAiPictures(color: String, category: String) {\r\n    const getUserSession = initializeDbConnection().session();\r\n    try {\r\n\r\n      const openai = new OpenAi({\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n      });\r\n\r\n      const result = await openai.images.generate({\r\n        prompt: `attractive feet with ${color} nailpolish and ${category}`,\r\n        n: 5,\r\n        size: \"256x256\",\r\n      })\r\n      \r\n      return result.data\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      getUserSession.close();\r\n    }\r\n  }\r\n\r\n  public async changePassword(email, userData) {\r\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\r\n    const hashedPassword = await hash(userData.data.password, 10);\r\n    const changePasswordSession = initializeDbConnection().session();\r\n    try {\r\n      const updatedUser = await changePasswordSession.executeWrite(tx =>\r\n        tx.run('match (u:user {email: $email}) set u.password: $password return u', {\r\n          email: email,\r\n          password: hashedPassword,\r\n        }),\r\n      );\r\n      if (!updatedUser.records.map(record => record.get('u').properties)) throw new HttpException(409, \"User doesn't exist\");\r\n      return updatedUser.records.map(record => record.get('u').properties);\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      changePasswordSession.close();\r\n    }\r\n  }\r\n\r\n  public async emailConfirming(token) {\r\n    const confirmEmailSession = initializeDbConnection().session();\r\n    try {\r\n      const tokenData: any = verify(token, process.env.EMAIL_SECRET);\r\n\r\n      const checkConfirmation = await confirmEmailSession.executeRead(tx =>\r\n        tx.run('match (u:user {id: $userId}) return u', {\r\n          userId: tokenData.data,\r\n        }),\r\n      );\r\n\r\n      if (checkConfirmation.records.map(record => record.get('u').properties.confirmed)[0]) return 'this account is already confirmed';\r\n\r\n      const confirmed = await confirmEmailSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId}) set u.confirmed = true return u', {\r\n          userId: tokenData.data,\r\n        }),\r\n      );\r\n\r\n      return confirmed.records.map(record => record.get('u').properties.confirmed)[0];\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      confirmEmailSession.close();\r\n    }\r\n  }\r\n\r\n  public async updateUser(userId: string, userData: any): Promise<User[]> {\r\n    const updateUserSession = initializeDbConnection().session();\r\n    try {\r\n      const existUser = await this.findUserById(userId);\r\n\r\n      const updatedUser = await updateUserSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId}) set u.name = $name, u.userName = $userName return u', {\r\n          userId: userId,\r\n          name: userData.data.name ? userData.data.name : existUser.name,\r\n          userName: userData.data.userName ? userData.data.userName : existUser.userName,\r\n        }),\r\n      );\r\n\r\n      return updatedUser.records.map(record => record.get('u').properties)[0];\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      updateUserSession.close();\r\n    }\r\n  }\r\n\r\n  public async buyPosts(userId: string, saleData: any) {\r\n    try {\r\n      const pricesPromises = await saleData.data.posts.map(post => {\r\n        return this.checkForSale(userId, post.id).then(exists => {\r\n          if (exists) return null;\r\n          return stripe.prices\r\n            .list({\r\n              product: post.id,\r\n            })\r\n            .then(price => {\r\n              return { price: price.data[0].id, quantity: 1 };\r\n            });\r\n        });\r\n      });\r\n\r\n      const prices = await Promise.all(pricesPromises);\r\n\r\n      if (prices.filter(price => price != null).length == 0) return { message: 'all posts selected have already been bought by this user' };\r\n\r\n      const sellersPromises = await saleData.data.posts.map(post => {\r\n        return stripe.products.retrieve(post.id).then(product => {\r\n          return stripe.prices\r\n            .list({\r\n              product: post.id,\r\n            })\r\n            .then(price => {\r\n              return { sellerId: product.metadata.sellerId, productId: post.id, amount: price.data[0].unit_amount };\r\n            });\r\n        });\r\n      });\r\n\r\n      const sellers = await Promise.all(sellersPromises);\r\n\r\n      const session = await stripe.checkout.sessions.create({\r\n        success_url: 'https://example.com/success',\r\n        line_items: prices.filter(price => price != null),\r\n        mode: 'payment',\r\n        customer: userId,\r\n        metadata: {\r\n          sellersIds: sellers\r\n            .map(record => {\r\n              return `sellerId:${record.sellerId}.postId:${record.productId}.amount:${record.amount * 0.01}`;\r\n            })\r\n            .toString(),\r\n        },\r\n      });\r\n\r\n      return session.url;\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  }\r\n\r\n  public getSellersByPostId = async (postId: string) => {\r\n    const getSellersByPostIdSession = initializeDbConnection().session();\r\n    try {\r\n      const sellers = await getSellersByPostIdSession.executeWrite(tx =>\r\n        tx.run('match (p:post {id: $postId})-[:HAS_A]-(s:seller) return s', {\r\n          postId: postId,\r\n        }),\r\n      );\r\n      return sellers.records.map(record => record.get('s').properties);\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      getSellersByPostIdSession.close();\r\n    }\r\n  };\r\n\r\n  public buyPost = async (postId: string, userId: string, sellerId: string, amount: number) => {\r\n    const buyPostSession = initializeDbConnection().session();\r\n    try {\r\n      await buyPostSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId}), (p:post {id: $postId}) create (u)-[bought:BOUGHT_A]->(p) return bought', {\r\n          userId: userId,\r\n          postId: postId,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      buyPostSession.close();\r\n    }\r\n  };\r\n\r\n  public subscribe = async (userId: string, subscriptionData: any) => {\r\n\r\n    const getSellerIdSession = initializeDbConnection().session();\r\n\r\n    try {\r\n\r\n      const seller = await getSellerIdSession.executeWrite(tx =>\r\n        tx.run('match (user {id: $userId})-[:IS_A]-(s:seller) return s', {\r\n          userId: subscriptionData.data.sellerId,\r\n        }),\r\n      );\r\n\r\n      const sellerId = seller.records.map(record => record.get(\"s\").properties.id)[0];\r\n\r\n      if (await this.checkForSubscription(userId, sellerId)) return { message: 'Already subscribed' };\r\n\r\n      const session = await stripe.checkout.sessions.create({\r\n        success_url: 'https://example.com/success',\r\n        line_items: [{ price: subscriptionData.data.subscriptionPlanId, quantity: 1 }],\r\n        mode: 'subscription',\r\n        currency: \"EUR\",\r\n        customer: userId,\r\n        metadata: {\r\n          sellerId: sellerId,\r\n          subscriptionPlanTitle: subscriptionData.data.subscriptionPlanTitle,\r\n          subscriptionPlanPrice: subscriptionData.data.subscriptionPlanPrice,\r\n        },\r\n      });\r\n\r\n      return session;\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  };\r\n\r\n  public createSubscriptioninDb = async (userId: string, sellerId: string, subscriptionPlanTitle: string, subscriptionPlanPrice: number) => {\r\n    const subscribeSession = initializeDbConnection().session();\r\n    try {\r\n      if (await this.checkForSubscription(userId, sellerId)) return { message: 'Already subscribed' };\r\n\r\n      await subscribeSession.executeWrite(tx => {\r\n        tx.run(\r\n          'match (u:user {id: $userId}), (s:seller {id: $sellerId})<-[:IS_A]-(user:user) create (u)-[:SUBSCRIBED_TO {subscriptionPlanTitle: $subscriptionPlanTitle, subscriptionPlanPrice: $subscriptionPlanPrice}]->(s) set user.followers = user.followers + 1 set u.followings = u.followings + 1 return s',\r\n          {\r\n            userId: userId,\r\n            sellerId: sellerId,\r\n            subscriptionPlanTitle: subscriptionPlanTitle,\r\n            subscriptionPlanPrice: subscriptionPlanPrice,\r\n          },\r\n        );\r\n      });\r\n      \r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      subscribeSession.close();\r\n    }\r\n  };\r\n\r\n  public cancelSubscription = async (userId: string, sellerId: string) => {\r\n\r\n    const cancelSubscriptionSession = initializeDbConnection().session();\r\n    try {\r\n      if (!(await this.checkForSubscription(userId, sellerId))) return { message: 'no subscription' };\r\n\r\n      await cancelSubscriptionSession.executeWrite(tx => {\r\n        tx.run('match (u:user {id: $userId})-[sub:SUBSCRIBED_TO]->(s:seller {id: $sellerId}) detach delete sub', {\r\n          userId: userId,\r\n          sellerId: sellerId,\r\n        });\r\n      });\r\n      return {message: 'subscription was canceled successfuly'};\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      cancelSubscriptionSession.close();\r\n    }\r\n  };\r\n\r\n  public checkForSale = async (userId: string, postId: string) => {\r\n    const checkForExistingRelationship = initializeDbConnection().session();\r\n    try {\r\n      const saleAlreadyExists = await checkForExistingRelationship.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId})-[bought:BOUGHT_A]->(p:post {id: $postId}) return bought', {\r\n          userId: userId,\r\n          postId: postId,\r\n        }),\r\n      );\r\n      \r\n\r\n      return saleAlreadyExists.records.map(record => record.get('bought')).length > 0 ? true : false;\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      checkForExistingRelationship.close();\r\n    }\r\n  };\r\n\r\n  public getSellerPlans = async (userId: string) => {\r\n    const getSellerPlansSession = initializeDbConnection().session();\r\n    try {\r\n      const sellerPlan = await getSellerPlansSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId})-[:IS_A]-(seller)-[:HAS_A]-(plan:plan) return plan', {\r\n          userId: userId,\r\n        }),\r\n      );\r\n\r\n      return sellerPlan.records.map(record => record.get('plan').properties);\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      getSellerPlansSession.close();\r\n    }\r\n  };\r\n\r\n  public checkForSubscription = async (userId: string, sellerId: string) => {\r\n    const checkForSubscriptionSession = initializeDbConnection().session();\r\n    try {\r\n      const subscriptionAlreadyExist = await checkForSubscriptionSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId})-[subscribed:SUBSCRIBED_TO]->(s:seller {id: $sellerId}) return subscribed', {\r\n          userId: userId,\r\n          sellerId: sellerId,\r\n        }),\r\n      );\r\n\r\n      return subscriptionAlreadyExist.records.map(record => record.get('subscribed')).length > 0 ? true : false;;\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      checkForSubscriptionSession.close();\r\n    }\r\n  };\r\n\r\n  public checkForSubscriptionbyUserId = async (userId: string, postId: string, plan: string) => {\r\n    const checkForSubscriptionSession = initializeDbConnection().session();\r\n    try {\r\n      \r\n      const subscriptionAlreadyExist = await checkForSubscriptionSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId})-[subscribed:SUBSCRIBED_TO {subscriptionPlanTitle: $plan}]->(s:seller)-[:HAS_A]->(p:post {id: $postId}) return subscribed', {\r\n          userId: userId,\r\n          postId: postId,\r\n          plan: plan\r\n        }),\r\n      );\r\n      \r\n\r\n      return subscriptionAlreadyExist.records.map(record => record.get('subscribed')).length > 0 ? true : false;\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      checkForSubscriptionSession.close();\r\n    }\r\n  };\r\n\r\n\r\n  public uploadAvatar = async (avatarData: any, userId: string) => {\r\n    try {\r\n      /* aws.config.update({\r\n        accessKeyId: process.env.AWS_ACCESS_KEY_ID,\r\n        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\r\n        region: 'us-east-2',\r\n      });\r\n      const filecontent = Buffer.from(avatarData.buffer, 'binary');\r\n      const s3 = new aws.S3();\r\n\r\n      const params = {\r\n        Bucket: process.env.AWS_BUCKET_NAME,\r\n        Key: `${avatarData.fieldname}avatar${userId}.${avatarData.mimetype.split('/')[1]}`,\r\n        Body: filecontent,\r\n      };\r\n\r\n      s3.upload(params, (err, data) => {\r\n        if (err) return console.log(err);\r\n        this.uploadAvatarToDb(data.Location, userId);\r\n      }); */\r\n\r\n      const filecontent = Buffer.from(avatarData.buffer, 'binary');\r\n\r\n      console.log(filecontent);\r\n      \r\n\r\n      writeFile(\r\n        path.join(__dirname, '../../public/files/avatars', `avatar${userId}.${avatarData.mimetype.split(\"/\")[1]}`),\r\n        filecontent,\r\n        async err => {\r\n          if (err) return console.log(err);\r\n          await this.uploadAvatarToDb(`/public/files/avatars/avatar${userId}.${avatarData.mimetype.split(\"/\")[1]}`, userId);\r\n        },\r\n      );\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  };\r\n\r\n  public uploadAvatarToDb = async (location: string, userId: string) => {\r\n    const uploadAvatarToDbSession = initializeDbConnection().session();\r\n    try {\r\n      await uploadAvatarToDbSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId}) set u.avatar = $avatar', {\r\n          userId: userId,\r\n          avatar: location,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      uploadAvatarToDbSession.close();\r\n    }\r\n  };\r\n\r\n  public async uploadDeviceToken(userId: string, token: string): Promise<void>  {\r\n    const uploadDeviceTokenSession = initializeDbConnection().session();\r\n    try {\r\n      await uploadDeviceTokenSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId}) create (u)-[:GOT_DEVICE]->(:device {token: $token})', {\r\n          userId: userId,\r\n          token: token,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      uploadDeviceTokenSession.close();\r\n    }\r\n  };\r\n\r\n  public async desactivateUser(userId: number): Promise<User[]> {\r\n    const desactivateUserSession = initializeDbConnection().session();\r\n    try {\r\n      const desactivatedUser = await desactivateUserSession.executeWrite(tx => tx.run('match (u:user {id: $userId}) set u.desactivated = true'));\r\n      return desactivatedUser.records.map(record => record.get('u').properties)[0];\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  }\r\n}\r\n\r\nexport default UserService;\r\n"],"names":["UserService","findUserById","userId","getUserSession","initializeDbConnection","session","result","executeRead","tx","run","records","length","HttpException","map","record","get","properties","error","console","log","close","generateAiPictures","color","category","openai","OpenAi","apiKey","process","env","OPENAI_API_KEY","images","generate","prompt","n","size","data","changePassword","email","userData","isEmpty","hashedPassword","hash","password","changePasswordSession","updatedUser","executeWrite","emailConfirming","token","confirmEmailSession","tokenData","verify","EMAIL_SECRET","checkConfirmation","confirmed","updateUser","updateUserSession","existUser","name","userName","buyPosts","saleData","pricesPromises","posts","post","checkForSale","id","then","exists","stripe","prices","list","product","price","quantity","Promise","all","filter","message","sellersPromises","products","retrieve","sellerId","metadata","productId","amount","unit_amount","sellers","checkout","sessions","create","success_url","line_items","mode","customer","sellersIds","toString","url","uploadDeviceToken","uploadDeviceTokenSession","desactivateUser","desactivateUserSession","desactivatedUser","getSellersByPostId","postId","getSellersByPostIdSession","buyPost","buyPostSession","subscribe","subscriptionData","getSellerIdSession","seller","checkForSubscription","subscriptionPlanId","currency","subscriptionPlanTitle","subscriptionPlanPrice","createSubscriptioninDb","subscribeSession","cancelSubscription","cancelSubscriptionSession","checkForExistingRelationship","saleAlreadyExists","getSellerPlans","getSellerPlansSession","sellerPlan","checkForSubscriptionSession","subscriptionAlreadyExist","checkForSubscriptionbyUserId","plan","uploadAvatar","avatarData","filecontent","Buffer","from","buffer","writeFile","path","join","__dirname","mimetype","split","err","uploadAvatarToDb","location","uploadAvatarToDbSession","avatar"],"mappings":";;;;+BA6bA;;;eAAA;;;wBA7bqB;+BACS;wBAEJ;4BACH;sBACC;qBACuB;8BACxB;iEACN;+DACE;;;;;;;;;;;;;;;;;;;AAEnB,IAAA,AAAMA,cAAN,MAAMA;IAGJ,MAAaC,aAAaC,MAAM,EAAE;QAChC,MAAMC,iBAAiBC,IAAAA,2BAAsB,IAAGC,OAAO;QACvD,IAAI;YACF,MAAMC,SAAS,MAAMH,eAAeI,WAAW,CAACC,CAAAA,KAC9CA,GAAGC,GAAG,CAAC,yCAAyC;oBAC9CP,QAAQA;gBACV;YAGF,IAAII,OAAOI,OAAO,CAACC,MAAM,IAAI,GAAG,MAAM,IAAIC,4BAAa,CAAC,KAAK;YAE7D,OAAON,OAAOI,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAAC,CAAC,EAAE;QACpE,EAAE,OAAOC,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd,SAAU;YACRd,eAAeiB,KAAK;QACtB;IACF;IAEA,MAAaC,mBAAmBC,KAAa,EAAEC,QAAgB,EAAE;QAC/D,MAAMpB,iBAAiBC,IAAAA,2BAAsB,IAAGC,OAAO;QACvD,IAAI;YAEF,MAAMmB,SAAS,IAAIC,eAAM,CAAC;gBACxBC,QAAQC,QAAQC,GAAG,CAACC,cAAc;YACpC;YAEA,MAAMvB,SAAS,MAAMkB,OAAOM,MAAM,CAACC,QAAQ,CAAC;gBAC1CC,QAAQ,CAAC,qBAAqB,EAAEV,MAAM,gBAAgB,EAAEC,SAAS,CAAC;gBAClEU,GAAG;gBACHC,MAAM;YACR;YAEA,OAAO5B,OAAO6B,IAAI;QACpB,EAAE,OAAOlB,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd,SAAU;YACRd,eAAeiB,KAAK;QACtB;IACF;IAEA,MAAagB,eAAeC,KAAK,EAAEC,QAAQ,EAAE;QAC3C,IAAIC,IAAAA,aAAO,EAACD,WAAW,MAAM,IAAI1B,4BAAa,CAAC,KAAK;QACpD,MAAM4B,iBAAiB,MAAMC,IAAAA,YAAI,EAACH,SAASH,IAAI,CAACO,QAAQ,EAAE;QAC1D,MAAMC,wBAAwBvC,IAAAA,2BAAsB,IAAGC,OAAO;QAC9D,IAAI;YACF,MAAMuC,cAAc,MAAMD,sBAAsBE,YAAY,CAACrC,CAAAA,KAC3DA,GAAGC,GAAG,CAAC,qEAAqE;oBAC1E4B,OAAOA;oBACPK,UAAUF;gBACZ;YAEF,IAAI,CAACI,YAAYlC,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,GAAG,MAAM,IAAIJ,4BAAa,CAAC,KAAK;YACjG,OAAOgC,YAAYlC,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU;QACrE,EAAE,OAAOC,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd,SAAU;YACR0B,sBAAsBvB,KAAK;QAC7B;IACF;IAEA,MAAa0B,gBAAgBC,KAAK,EAAE;QAClC,MAAMC,sBAAsB5C,IAAAA,2BAAsB,IAAGC,OAAO;QAC5D,IAAI;YACF,MAAM4C,YAAiBC,IAAAA,oBAAM,EAACH,OAAOpB,QAAQC,GAAG,CAACuB,YAAY;YAE7D,MAAMC,oBAAoB,MAAMJ,oBAAoBzC,WAAW,CAACC,CAAAA,KAC9DA,GAAGC,GAAG,CAAC,yCAAyC;oBAC9CP,QAAQ+C,UAAUd,IAAI;gBACxB;YAGF,IAAIiB,kBAAkB1C,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAACqC,SAAS,CAAC,CAAC,EAAE,EAAE,OAAO;YAE7F,MAAMA,YAAY,MAAML,oBAAoBH,YAAY,CAACrC,CAAAA,KACvDA,GAAGC,GAAG,CAAC,gEAAgE;oBACrEP,QAAQ+C,UAAUd,IAAI;gBACxB;YAGF,OAAOkB,UAAU3C,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAACqC,SAAS,CAAC,CAAC,EAAE;QACjF,EAAE,OAAOpC,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd,SAAU;YACR+B,oBAAoB5B,KAAK;QAC3B;IACF;IAEA,MAAakC,WAAWpD,MAAc,EAAEoC,QAAa,EAAmB;QACtE,MAAMiB,oBAAoBnD,IAAAA,2BAAsB,IAAGC,OAAO;QAC1D,IAAI;YACF,MAAMmD,YAAY,MAAM,IAAI,CAACvD,YAAY,CAACC;YAE1C,MAAM0C,cAAc,MAAMW,kBAAkBV,YAAY,CAACrC,CAAAA,KACvDA,GAAGC,GAAG,CAAC,oFAAoF;oBACzFP,QAAQA;oBACRuD,MAAMnB,SAASH,IAAI,CAACsB,IAAI,GAAGnB,SAASH,IAAI,CAACsB,IAAI,GAAGD,UAAUC,IAAI;oBAC9DC,UAAUpB,SAASH,IAAI,CAACuB,QAAQ,GAAGpB,SAASH,IAAI,CAACuB,QAAQ,GAAGF,UAAUE,QAAQ;gBAChF;YAGF,OAAOd,YAAYlC,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAAC,CAAC,EAAE;QACzE,EAAE,OAAOC,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd,SAAU;YACRsC,kBAAkBnC,KAAK;QACzB;IACF;IAEA,MAAauC,SAASzD,MAAc,EAAE0D,QAAa,EAAE;QACnD,IAAI;YACF,MAAMC,iBAAiB,MAAMD,SAASzB,IAAI,CAAC2B,KAAK,CAACjD,GAAG,CAACkD,CAAAA;gBACnD,OAAO,IAAI,CAACC,YAAY,CAAC9D,QAAQ6D,KAAKE,EAAE,EAAEC,IAAI,CAACC,CAAAA;oBAC7C,IAAIA,QAAQ,OAAO;oBACnB,OAAOC,WAAM,CAACC,MAAM,CACjBC,IAAI,CAAC;wBACJC,SAASR,KAAKE,EAAE;oBAClB,GACCC,IAAI,CAACM,CAAAA;wBACJ,OAAO;4BAAEA,OAAOA,MAAMrC,IAAI,CAAC,EAAE,CAAC8B,EAAE;4BAAEQ,UAAU;wBAAE;oBAChD;gBACJ;YACF;YAEA,MAAMJ,SAAS,MAAMK,QAAQC,GAAG,CAACd;YAEjC,IAAIQ,OAAOO,MAAM,CAACJ,CAAAA,QAASA,SAAS,MAAM7D,MAAM,IAAI,GAAG,OAAO;gBAAEkE,SAAS;YAA2D;YAEpI,MAAMC,kBAAkB,MAAMlB,SAASzB,IAAI,CAAC2B,KAAK,CAACjD,GAAG,CAACkD,CAAAA;gBACpD,OAAOK,WAAM,CAACW,QAAQ,CAACC,QAAQ,CAACjB,KAAKE,EAAE,EAAEC,IAAI,CAACK,CAAAA;oBAC5C,OAAOH,WAAM,CAACC,MAAM,CACjBC,IAAI,CAAC;wBACJC,SAASR,KAAKE,EAAE;oBAClB,GACCC,IAAI,CAACM,CAAAA;wBACJ,OAAO;4BAAES,UAAUV,QAAQW,QAAQ,CAACD,QAAQ;4BAAEE,WAAWpB,KAAKE,EAAE;4BAAEmB,QAAQZ,MAAMrC,IAAI,CAAC,EAAE,CAACkD,WAAW;wBAAC;oBACtG;gBACJ;YACF;YAEA,MAAMC,UAAU,MAAMZ,QAAQC,GAAG,CAACG;YAElC,MAAMzE,UAAU,MAAM+D,WAAM,CAACmB,QAAQ,CAACC,QAAQ,CAACC,MAAM,CAAC;gBACpDC,aAAa;gBACbC,YAAYtB,OAAOO,MAAM,CAACJ,CAAAA,QAASA,SAAS;gBAC5CoB,MAAM;gBACNC,UAAU3F;gBACVgF,UAAU;oBACRY,YAAYR,QACTzE,GAAG,CAACC,CAAAA;wBACH,OAAO,CAAC,SAAS,EAAEA,OAAOmE,QAAQ,CAAC,QAAQ,EAAEnE,OAAOqE,SAAS,CAAC,QAAQ,EAAErE,OAAOsE,MAAM,GAAG,KAAK,CAAC;oBAChG,GACCW,QAAQ;gBACb;YACF;YAEA,OAAO1F,QAAQ2F,GAAG;QACpB,EAAE,OAAO/E,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd;IACF;IAoPA,MAAagF,kBAAkB/F,MAAc,EAAE6C,KAAa,EAAkB;QAC5E,MAAMmD,2BAA2B9F,IAAAA,2BAAsB,IAAGC,OAAO;QACjE,IAAI;YACF,MAAM6F,yBAAyBrD,YAAY,CAACrC,CAAAA,KAC1CA,GAAGC,GAAG,CAAC,oFAAoF;oBACzFP,QAAQA;oBACR6C,OAAOA;gBACT;QAEJ,EAAE,OAAO9B,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd,SAAU;YACRiF,yBAAyB9E,KAAK;QAChC;IACF;IAEA,MAAa+E,gBAAgBjG,MAAc,EAAmB;QAC5D,MAAMkG,yBAAyBhG,IAAAA,2BAAsB,IAAGC,OAAO;QAC/D,IAAI;YACF,MAAMgG,mBAAmB,MAAMD,uBAAuBvD,YAAY,CAACrC,CAAAA,KAAMA,GAAGC,GAAG,CAAC;YAChF,OAAO4F,iBAAiB3F,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAAC,CAAC,EAAE;QAC9E,EAAE,OAAOC,OAAO;YACdC,QAAQC,GAAG,CAACF;QACd;IACF;;QA9aA,uBAAOoD,UAAS,EAAE;QAoKlB,uBAAOiC,sBAAqB,OAAOC;YACjC,MAAMC,4BAA4BpG,IAAAA,2BAAsB,IAAGC,OAAO;YAClE,IAAI;gBACF,MAAMiF,UAAU,MAAMkB,0BAA0B3D,YAAY,CAACrC,CAAAA,KAC3DA,GAAGC,GAAG,CAAC,6DAA6D;wBAClE8F,QAAQA;oBACV;gBAEF,OAAOjB,QAAQ5E,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU;YACjE,EAAE,OAAOC,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd,SAAU;gBACRuF,0BAA0BpF,KAAK;YACjC;QACF;QAEA,uBAAOqF,WAAU,OAAOF,QAAgBrG,QAAgB+E,UAAkBG;YACxE,MAAMsB,iBAAiBtG,IAAAA,2BAAsB,IAAGC,OAAO;YACvD,IAAI;gBACF,MAAMqG,eAAe7D,YAAY,CAACrC,CAAAA,KAChCA,GAAGC,GAAG,CAAC,wGAAwG;wBAC7GP,QAAQA;wBACRqG,QAAQA;oBACV;YAEJ,EAAE,OAAOtF,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd,SAAU;gBACRyF,eAAetF,KAAK;YACtB;QACF;QAEA,uBAAOuF,aAAY,OAAOzG,QAAgB0G;YAExC,MAAMC,qBAAqBzG,IAAAA,2BAAsB,IAAGC,OAAO;YAE3D,IAAI;gBAEF,MAAMyG,SAAS,MAAMD,mBAAmBhE,YAAY,CAACrC,CAAAA,KACnDA,GAAGC,GAAG,CAAC,0DAA0D;wBAC/DP,QAAQ0G,iBAAiBzE,IAAI,CAAC8C,QAAQ;oBACxC;gBAGF,MAAMA,WAAW6B,OAAOpG,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,KAAKC,UAAU,CAACiD,EAAE,CAAC,CAAC,EAAE;gBAE/E,IAAI,MAAM,IAAI,CAAC8C,oBAAoB,CAAC7G,QAAQ+E,WAAW,OAAO;oBAAEJ,SAAS;gBAAqB;gBAE9F,MAAMxE,UAAU,MAAM+D,WAAM,CAACmB,QAAQ,CAACC,QAAQ,CAACC,MAAM,CAAC;oBACpDC,aAAa;oBACbC,YAAY;wBAAC;4BAAEnB,OAAOoC,iBAAiBzE,IAAI,CAAC6E,kBAAkB;4BAAEvC,UAAU;wBAAE;qBAAE;oBAC9EmB,MAAM;oBACNqB,UAAU;oBACVpB,UAAU3F;oBACVgF,UAAU;wBACRD,UAAUA;wBACViC,uBAAuBN,iBAAiBzE,IAAI,CAAC+E,qBAAqB;wBAClEC,uBAAuBP,iBAAiBzE,IAAI,CAACgF,qBAAqB;oBACpE;gBACF;gBAEA,OAAO9G;YACT,EAAE,OAAOY,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd;QACF;QAEA,uBAAOmG,0BAAyB,OAAOlH,QAAgB+E,UAAkBiC,uBAA+BC;YACtG,MAAME,mBAAmBjH,IAAAA,2BAAsB,IAAGC,OAAO;YACzD,IAAI;gBACF,IAAI,MAAM,IAAI,CAAC0G,oBAAoB,CAAC7G,QAAQ+E,WAAW,OAAO;oBAAEJ,SAAS;gBAAqB;gBAE9F,MAAMwC,iBAAiBxE,YAAY,CAACrC,CAAAA;oBAClCA,GAAGC,GAAG,CACJ,sSACA;wBACEP,QAAQA;wBACR+E,UAAUA;wBACViC,uBAAuBA;wBACvBC,uBAAuBA;oBACzB;gBAEJ;YAEF,EAAE,OAAOlG,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd,SAAU;gBACRoG,iBAAiBjG,KAAK;YACxB;QACF;QAEA,uBAAOkG,sBAAqB,OAAOpH,QAAgB+E;YAEjD,MAAMsC,4BAA4BnH,IAAAA,2BAAsB,IAAGC,OAAO;YAClE,IAAI;gBACF,IAAI,CAAE,MAAM,IAAI,CAAC0G,oBAAoB,CAAC7G,QAAQ+E,WAAY,OAAO;oBAAEJ,SAAS;gBAAkB;gBAE9F,MAAM0C,0BAA0B1E,YAAY,CAACrC,CAAAA;oBAC3CA,GAAGC,GAAG,CAAC,kGAAkG;wBACvGP,QAAQA;wBACR+E,UAAUA;oBACZ;gBACF;gBACA,OAAO;oBAACJ,SAAS;gBAAuC;YAC1D,EAAE,OAAO5D,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd,SAAU;gBACRsG,0BAA0BnG,KAAK;YACjC;QACF;QAEA,uBAAO4C,gBAAe,OAAO9D,QAAgBqG;YAC3C,MAAMiB,+BAA+BpH,IAAAA,2BAAsB,IAAGC,OAAO;YACrE,IAAI;gBACF,MAAMoH,oBAAoB,MAAMD,6BAA6B3E,YAAY,CAACrC,CAAAA,KACxEA,GAAGC,GAAG,CAAC,wFAAwF;wBAC7FP,QAAQA;wBACRqG,QAAQA;oBACV;gBAIF,OAAOkB,kBAAkB/G,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,WAAWJ,MAAM,GAAG,IAAI,OAAO;YAC3F,EAAE,OAAOM,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd,SAAU;gBACRuG,6BAA6BpG,KAAK;YACpC;QACF;QAEA,uBAAOsG,kBAAiB,OAAOxH;YAC7B,MAAMyH,wBAAwBvH,IAAAA,2BAAsB,IAAGC,OAAO;YAC9D,IAAI;gBACF,MAAMuH,aAAa,MAAMD,sBAAsB9E,YAAY,CAACrC,CAAAA,KAC1DA,GAAGC,GAAG,CAAC,kFAAkF;wBACvFP,QAAQA;oBACV;gBAGF,OAAO0H,WAAWlH,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,QAAQC,UAAU;YACvE,EAAE,OAAOC,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd,SAAU;gBACR0G,sBAAsBvG,KAAK;YAC7B;QACF;QAEA,uBAAO2F,wBAAuB,OAAO7G,QAAgB+E;YACnD,MAAM4C,8BAA8BzH,IAAAA,2BAAsB,IAAGC,OAAO;YACpE,IAAI;gBACF,MAAMyH,2BAA2B,MAAMD,4BAA4BhF,YAAY,CAACrC,CAAAA,KAC9EA,GAAGC,GAAG,CAAC,yGAAyG;wBAC9GP,QAAQA;wBACR+E,UAAUA;oBACZ;gBAGF,OAAO6C,yBAAyBpH,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,eAAeJ,MAAM,GAAG,IAAI,OAAO;YACtG,EAAE,OAAOM,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd,SAAU;gBACR4G,4BAA4BzG,KAAK;YACnC;QACF;QAEA,uBAAO2G,gCAA+B,OAAO7H,QAAgBqG,QAAgByB;YAC3E,MAAMH,8BAA8BzH,IAAAA,2BAAsB,IAAGC,OAAO;YACpE,IAAI;gBAEF,MAAMyH,2BAA2B,MAAMD,4BAA4BhF,YAAY,CAACrC,CAAAA,KAC9EA,GAAGC,GAAG,CAAC,yJAAyJ;wBAC9JP,QAAQA;wBACRqG,QAAQA;wBACRyB,MAAMA;oBACR;gBAIF,OAAOF,yBAAyBpH,OAAO,CAACG,GAAG,CAACC,CAAAA,SAAUA,OAAOC,GAAG,CAAC,eAAeJ,MAAM,GAAG,IAAI,OAAO;YACtG,EAAE,OAAOM,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd,SAAU;gBACR4G,4BAA4BzG,KAAK;YACnC;QACF;QAGA,uBAAO6G,gBAAe,OAAOC,YAAiBhI;YAC5C,IAAI;gBACF;;;;;;;;;;;;;;;;;UAiBI,GAEJ,MAAMiI,cAAcC,kBAAM,CAACC,IAAI,CAACH,WAAWI,MAAM,EAAE;gBAEnDpH,QAAQC,GAAG,CAACgH;gBAGZI,IAAAA,iBAAS,EACPC,iBAAI,CAACC,IAAI,CAACC,WAAW,8BAA8B,CAAC,MAAM,EAAExI,OAAO,CAAC,EAAEgI,WAAWS,QAAQ,CAACC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,GACzGT,aACA,OAAMU;oBACJ,IAAIA,KAAK,OAAO3H,QAAQC,GAAG,CAAC0H;oBAC5B,MAAM,IAAI,CAACC,gBAAgB,CAAC,CAAC,4BAA4B,EAAE5I,OAAO,CAAC,EAAEgI,WAAWS,QAAQ,CAACC,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAE1I;gBAC5G;YAEJ,EAAE,OAAOe,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd;QACF;QAEA,uBAAO6H,oBAAmB,OAAOC,UAAkB7I;YACjD,MAAM8I,0BAA0B5I,IAAAA,2BAAsB,IAAGC,OAAO;YAChE,IAAI;gBACF,MAAM2I,wBAAwBnG,YAAY,CAACrC,CAAAA,KACzCA,GAAGC,GAAG,CAAC,uDAAuD;wBAC5DP,QAAQA;wBACR+I,QAAQF;oBACV;YAEJ,EAAE,OAAO9H,OAAO;gBACdC,QAAQC,GAAG,CAACF;YACd,SAAU;gBACR+H,wBAAwB5H,KAAK;YAC/B;QACF;;AA2BF;MAEA,WAAepB"}
{"version":3,"sources":["../../src/services/users.service.ts"],"sourcesContent":["import { hash } from 'bcrypt';\r\nimport { HttpException } from '@exceptions/HttpException';\r\nimport { User } from '@interfaces/users.interface';\r\nimport { writeFile } from 'node:fs';\r\nimport { Buffer } from 'node:buffer';\r\nimport { isEmpty } from '@utils/util';\r\nimport { initializeDbConnection } from '@/app';\r\nimport { verify } from 'jsonwebtoken';\r\nimport path from 'node:path';\r\nimport Stripe from 'stripe';\r\nimport OpenAi from 'openai';\r\n\r\nclass UserService {\r\n  private stripe = new Stripe(process.env.STRIPE_TEST_KEY, { apiVersion: '2022-11-15' });\r\n  public prices = [];\r\n\r\n  public async findUserById(userId) {\r\n    const getUserSession = initializeDbConnection().session();\r\n    try {\r\n      const result = await getUserSession.executeRead(tx =>\r\n        tx.run('match (u:user {id: $userId}) return u', {\r\n          userId: userId,\r\n        }),\r\n      );\r\n\r\n      if (result.records.length == 0) throw new HttpException(409, \"User doesn't exist\");\r\n\r\n      return result.records.map(record => record.get('u').properties)[0];\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      getUserSession.close();\r\n    }\r\n  }\r\n\r\n  public async generateAiPictures(color: String, category: String) {\r\n    const getUserSession = initializeDbConnection().session();\r\n    try {\r\n\r\n      const openai = new OpenAi({\r\n        apiKey: process.env.OPENAI_API_KEY,\r\n      });\r\n\r\n      const result = await openai.images.generate({\r\n        prompt: `attractive feet with ${color} nailpolish and ${category}`,\r\n        n: 5,\r\n        size: \"256x256\",\r\n      })\r\n      \r\n      return result.data\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      getUserSession.close();\r\n    }\r\n  }\r\n\r\n  public async changePassword(email, userData) {\r\n    if (isEmpty(userData)) throw new HttpException(400, 'userData is empty');\r\n    const hashedPassword = await hash(userData.data.password, 10);\r\n    const changePasswordSession = initializeDbConnection().session();\r\n    try {\r\n      const updatedUser = await changePasswordSession.executeWrite(tx =>\r\n        tx.run('match (u:user {email: $email}) set u.password: $password return u', {\r\n          email: email,\r\n          password: hashedPassword,\r\n        }),\r\n      );\r\n      if (!updatedUser.records.map(record => record.get('u').properties)) throw new HttpException(409, \"User doesn't exist\");\r\n      return updatedUser.records.map(record => record.get('u').properties);\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      changePasswordSession.close();\r\n    }\r\n  }\r\n\r\n  public async emailConfirming(token) {\r\n    const confirmEmailSession = initializeDbConnection().session();\r\n    try {\r\n      const tokenData: any = verify(token, process.env.EMAIL_SECRET);\r\n\r\n      const checkConfirmation = await confirmEmailSession.executeRead(tx =>\r\n        tx.run('match (u:user {id: $userId}) return u', {\r\n          userId: tokenData.data,\r\n        }),\r\n      );\r\n\r\n      if (checkConfirmation.records.map(record => record.get('u').properties.confirmed)[0]) return 'this account is already confirmed';\r\n\r\n      const confirmed = await confirmEmailSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId}) set u.confirmed = true return u', {\r\n          userId: tokenData.data,\r\n        }),\r\n      );\r\n\r\n      return confirmed.records.map(record => record.get('u').properties.confirmed)[0];\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      confirmEmailSession.close();\r\n    }\r\n  }\r\n\r\n  public async updateUser(userId: string, userData: any): Promise<User[]> {\r\n    const updateUserSession = initializeDbConnection().session();\r\n    try {\r\n      const existUser = await this.findUserById(userId);\r\n\r\n      const updatedUser = await updateUserSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId}) set u.name = $name, u.userName = $userName return u', {\r\n          userId: userId,\r\n          name: userData.data.name ? userData.data.name : existUser.name,\r\n          userName: userData.data.userName ? userData.data.userName : existUser.userName,\r\n        }),\r\n      );\r\n\r\n      return updatedUser.records.map(record => record.get('u').properties)[0];\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      updateUserSession.close();\r\n    }\r\n  }\r\n\r\n  public async buyPosts(userId: string, saleData: any) {\r\n    try {\r\n      const pricesPromises = await saleData.data.posts.map(post => {\r\n        return this.checkForSale(userId, post.id).then(exists => {\r\n          if (exists) return null;\r\n          return this.stripe.prices\r\n            .list({\r\n              product: post.id,\r\n            })\r\n            .then(price => {\r\n              return { price: price.data[0].id, quantity: 1 };\r\n            });\r\n        });\r\n      });\r\n\r\n      const prices = await Promise.all(pricesPromises);\r\n\r\n      if (prices.filter(price => price != null).length == 0) return { message: 'all posts selected have already been bought by this user' };\r\n\r\n      const sellersPromises = await saleData.data.posts.map(post => {\r\n        return this.stripe.products.retrieve(post.id).then(product => {\r\n          return this.stripe.prices\r\n            .list({\r\n              product: post.id,\r\n            })\r\n            .then(price => {\r\n              return { sellerId: product.metadata.sellerId, productId: post.id, amount: price.data[0].unit_amount };\r\n            });\r\n        });\r\n      });\r\n\r\n      const sellers = await Promise.all(sellersPromises);\r\n\r\n      const session = await this.stripe.checkout.sessions.create({\r\n        success_url: 'https://example.com/success',\r\n        line_items: prices.filter(price => price != null),\r\n        mode: 'payment',\r\n        customer: userId,\r\n        metadata: {\r\n          sellersIds: sellers\r\n            .map(record => {\r\n              return `sellerId:${record.sellerId}.postId:${record.productId}.amount:${record.amount * 0.01}`;\r\n            })\r\n            .toString(),\r\n        },\r\n      });\r\n\r\n      return session.url;\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  }\r\n\r\n  public getSellersByPostId = async (postId: string) => {\r\n    const getSellersByPostIdSession = initializeDbConnection().session();\r\n    try {\r\n      const sellers = await getSellersByPostIdSession.executeWrite(tx =>\r\n        tx.run('match (p:post {id: $postId})-[:HAS_A]-(s:seller) return s', {\r\n          postId: postId,\r\n        }),\r\n      );\r\n      return sellers.records.map(record => record.get('s').properties);\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      getSellersByPostIdSession.close();\r\n    }\r\n  };\r\n\r\n  public buyPost = async (postId: string, userId: string, sellerId: string, amount: number) => {\r\n    const buyPostSession = initializeDbConnection().session();\r\n    try {\r\n      await buyPostSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId}), (p:post {id: $postId}) create (u)-[bought:BOUGHT_A]->(p) return bought', {\r\n          userId: userId,\r\n          postId: postId,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      buyPostSession.close();\r\n    }\r\n  };\r\n\r\n  public subscribe = async (userId: string, subscriptionData: any) => {\r\n\r\n    const getSellerIdSession = initializeDbConnection().session();\r\n\r\n    try {\r\n\r\n      const seller = await getSellerIdSession.executeWrite(tx =>\r\n        tx.run('match (user {id: $userId})-[:IS_A]-(s:seller) return s', {\r\n          userId: subscriptionData.data.sellerId,\r\n        }),\r\n      );\r\n\r\n      const sellerId = seller.records.map(record => record.get(\"s\").properties.id)[0];\r\n\r\n      if (await this.checkForSubscription(userId, sellerId)) return { message: 'Already subscribed' };\r\n\r\n      const session = await this.stripe.checkout.sessions.create({\r\n        success_url: 'https://example.com/success',\r\n        line_items: [{ price: subscriptionData.data.subscriptionPlanId, quantity: 1 }],\r\n        mode: 'subscription',\r\n        currency: \"EUR\",\r\n        customer: userId,\r\n        metadata: {\r\n          sellerId: sellerId,\r\n          subscriptionPlanTitle: subscriptionData.data.subscriptionPlanTitle,\r\n          subscriptionPlanPrice: subscriptionData.data.subscriptionPlanPrice,\r\n        },\r\n      });\r\n\r\n      return session;\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  };\r\n\r\n  public createSubscriptioninDb = async (userId: string, sellerId: string, subscriptionPlanTitle: string, subscriptionPlanPrice: number) => {\r\n    const subscribeSession = initializeDbConnection().session();\r\n    try {\r\n      if (await this.checkForSubscription(userId, sellerId)) return { message: 'Already subscribed' };\r\n\r\n      await subscribeSession.executeWrite(tx => {\r\n        tx.run(\r\n          'match (u:user {id: $userId}), (s:seller {id: $sellerId})<-[:IS_A]-(user:user) create (u)-[:SUBSCRIBED_TO {subscriptionPlanTitle: $subscriptionPlanTitle, subscriptionPlanPrice: $subscriptionPlanPrice}]->(s) set user.followers = user.followers + 1 set u.followings = u.followings + 1 return s',\r\n          {\r\n            userId: userId,\r\n            sellerId: sellerId,\r\n            subscriptionPlanTitle: subscriptionPlanTitle,\r\n            subscriptionPlanPrice: subscriptionPlanPrice,\r\n          },\r\n        );\r\n      });\r\n      \r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      subscribeSession.close();\r\n    }\r\n  };\r\n\r\n  public cancelSubscription = async (userId: string, sellerId: string) => {\r\n\r\n    const cancelSubscriptionSession = initializeDbConnection().session();\r\n    try {\r\n      if (!(await this.checkForSubscription(userId, sellerId))) return { message: 'no subscription' };\r\n\r\n      await cancelSubscriptionSession.executeWrite(tx => {\r\n        tx.run('match (u:user {id: $userId})-[sub:SUBSCRIBED_TO]->(s:seller {id: $sellerId}) detach delete sub', {\r\n          userId: userId,\r\n          sellerId: sellerId,\r\n        });\r\n      });\r\n      return {message: 'subscription was canceled successfuly'};\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      cancelSubscriptionSession.close();\r\n    }\r\n  };\r\n\r\n  public checkForSale = async (userId: string, postId: string) => {\r\n    const checkForExistingRelationship = initializeDbConnection().session();\r\n    try {\r\n      const saleAlreadyExists = await checkForExistingRelationship.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId})-[bought:BOUGHT_A]->(p:post {id: $postId}) return bought', {\r\n          userId: userId,\r\n          postId: postId,\r\n        }),\r\n      );\r\n      \r\n\r\n      return saleAlreadyExists.records.map(record => record.get('bought')).length > 0 ? true : false;\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      checkForExistingRelationship.close();\r\n    }\r\n  };\r\n\r\n  public getSellerPlans = async (userId: string) => {\r\n    const getSellerPlansSession = initializeDbConnection().session();\r\n    try {\r\n      const sellerPlan = await getSellerPlansSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId})-[:IS_A]-(seller)-[:HAS_A]-(plan:plan) return plan', {\r\n          userId: userId,\r\n        }),\r\n      );\r\n\r\n      return sellerPlan.records.map(record => record.get('plan').properties);\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      getSellerPlansSession.close();\r\n    }\r\n  };\r\n\r\n  public checkForSubscription = async (userId: string, sellerId: string) => {\r\n    const checkForSubscriptionSession = initializeDbConnection().session();\r\n    try {\r\n      const subscriptionAlreadyExist = await checkForSubscriptionSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId})-[subscribed:SUBSCRIBED_TO]->(s:seller {id: $sellerId}) return subscribed', {\r\n          userId: userId,\r\n          sellerId: sellerId,\r\n        }),\r\n      );\r\n\r\n      return subscriptionAlreadyExist.records.map(record => record.get('subscribed')).length > 0 ? true : false;;\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      checkForSubscriptionSession.close();\r\n    }\r\n  };\r\n\r\n  public checkForSubscriptionbyUserId = async (userId: string, postId: string, plan: string) => {\r\n    const checkForSubscriptionSession = initializeDbConnection().session();\r\n    try {\r\n      \r\n      const subscriptionAlreadyExist = await checkForSubscriptionSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId})-[subscribed:SUBSCRIBED_TO {subscriptionPlanTitle: $plan}]->(s:seller)-[:HAS_A]->(p:post {id: $postId}) return subscribed', {\r\n          userId: userId,\r\n          postId: postId,\r\n          plan: plan\r\n        }),\r\n      );\r\n      \r\n\r\n      return subscriptionAlreadyExist.records.map(record => record.get('subscribed')).length > 0 ? true : false;\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      checkForSubscriptionSession.close();\r\n    }\r\n  };\r\n\r\n\r\n  public uploadAvatar = async (avatarData: any, userId: string) => {\r\n    try {\r\n      /* aws.config.update({\r\n        accessKeyId: process.env.AWS_ACCESS_KEY_ID,\r\n        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\r\n        region: 'us-east-2',\r\n      });\r\n      const filecontent = Buffer.from(avatarData.buffer, 'binary');\r\n      const s3 = new aws.S3();\r\n\r\n      const params = {\r\n        Bucket: process.env.AWS_BUCKET_NAME,\r\n        Key: `${avatarData.fieldname}avatar${userId}.${avatarData.mimetype.split('/')[1]}`,\r\n        Body: filecontent,\r\n      };\r\n\r\n      s3.upload(params, (err, data) => {\r\n        if (err) return console.log(err);\r\n        this.uploadAvatarToDb(data.Location, userId);\r\n      }); */\r\n\r\n      const filecontent = Buffer.from(avatarData.buffer, 'binary');\r\n\r\n      console.log(filecontent);\r\n      \r\n\r\n      writeFile(\r\n        path.join(__dirname, '../../public/files/avatars', `avatar${userId}.${avatarData.mimetype.split(\"/\")[1]}`),\r\n        filecontent,\r\n        async err => {\r\n          if (err) return console.log(err);\r\n          await this.uploadAvatarToDb(`/public/files/avatars/avatar${userId}.${avatarData.mimetype.split(\"/\")[1]}`, userId);\r\n        },\r\n      );\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  };\r\n\r\n  public uploadAvatarToDb = async (location: string, userId: string) => {\r\n    const uploadAvatarToDbSession = initializeDbConnection().session();\r\n    try {\r\n      await uploadAvatarToDbSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId}) set u.avatar = $avatar', {\r\n          userId: userId,\r\n          avatar: location,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      uploadAvatarToDbSession.close();\r\n    }\r\n  };\r\n\r\n  public async uploadDeviceToken(userId: string, token: string): Promise<void>  {\r\n    const uploadDeviceTokenSession = initializeDbConnection().session();\r\n    try {\r\n      await uploadDeviceTokenSession.executeWrite(tx =>\r\n        tx.run('match (u:user {id: $userId}) create (u)-[:GOT_DEVICE]->(:device {token: $token})', {\r\n          userId: userId,\r\n          token: token,\r\n        }),\r\n      );\r\n    } catch (error) {\r\n      console.log(error);\r\n    } finally {\r\n      uploadDeviceTokenSession.close();\r\n    }\r\n  };\r\n\r\n  public async desactivateUser(userId: number): Promise<User[]> {\r\n    const desactivateUserSession = initializeDbConnection().session();\r\n    try {\r\n      const desactivatedUser = await desactivateUserSession.executeWrite(tx => tx.run('match (u:user {id: $userId}) set u.desactivated = true'));\r\n      return desactivatedUser.records.map(record => record.get('u').properties)[0];\r\n    } catch (error) {\r\n      console.log(error);\r\n    }\r\n  }\r\n}\r\n\r\nexport default UserService;\r\n"],"names":["UserService","findUserById","userId","getUserSession","initializeDbConnection","session","result","executeRead","tx","run","records","length","HttpException","map","record","get","properties","error","console","log","close","generateAiPictures","color","category","openai","OpenAi","apiKey","process","env","OPENAI_API_KEY","images","generate","prompt","n","size","data","changePassword","email","userData","isEmpty","hashedPassword","hash","password","changePasswordSession","updatedUser","executeWrite","emailConfirming","token","confirmEmailSession","tokenData","verify","EMAIL_SECRET","checkConfirmation","confirmed","updateUser","updateUserSession","existUser","name","userName","buyPosts","saleData","pricesPromises","posts","post","checkForSale","id","then","exists","stripe","prices","list","product","price","quantity","Promise","all","filter","message","sellersPromises","products","retrieve","sellerId","metadata","productId","amount","unit_amount","sellers","checkout","sessions","create","success_url","line_items","mode","customer","sellersIds","toString","url","uploadDeviceToken","uploadDeviceTokenSession","desactivateUser","desactivateUserSession","desactivatedUser","Stripe","STRIPE_TEST_KEY","apiVersion","getSellersByPostId","postId","getSellersByPostIdSession","buyPost","buyPostSession","subscribe","subscriptionData","getSellerIdSession","seller","checkForSubscription","subscriptionPlanId","currency","subscriptionPlanTitle","subscriptionPlanPrice","createSubscriptioninDb","subscribeSession","cancelSubscription","cancelSubscriptionSession","checkForExistingRelationship","saleAlreadyExists","getSellerPlans","getSellerPlansSession","sellerPlan","checkForSubscriptionSession","subscriptionAlreadyExist","checkForSubscriptionbyUserId","plan","uploadAvatar","avatarData","filecontent","Buffer","from","buffer","writeFile","path","join","__dirname","mimetype","split","err","uploadAvatarToDb","location","uploadAvatarToDbSession","avatar"],"mappings":"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"}